# V1.6 Victron Cerbo Integration - Implementation Prompt

**Version:** V1.5.0 → V1.6.0
**Date:** December 10, 2025
**Estimated Time:** 1 week (15-20 hours)
**Priority:** High - Foundation for V2 data collection
**Context:** [V2_Roadmap.md](../V2_Roadmap.md) - V1.6 Data Foundation

---

## 🎯 Objective

Integrate Victron Cerbo GX battery monitoring via VRM Cloud API to provide **accurate, real-time battery data** as the primary source of truth for battery state of charge (SOC), voltage, current, and temperature.

**Why This Matters:**
- Current SolArk API provides battery data, but Victron Cerbo is connected directly to the battery shunt
- Cerbo provides more accurate, detailed battery metrics
- Foundation for V2 autonomous control and optimization
- Enables better battery health monitoring and degradation tracking

---

## 📚 Background Context

### Current System (V1.5)
- **Battery Data Source:** SolArk inverter API (192.168.1.23)
- **Polling:** Every 30 seconds
- **Metrics:** SOC, battery power (charge/discharge)
- **Limitation:** Indirect measurement through inverter, less accurate

### Target System (V1.6)
- **Primary Battery Source:** Victron Cerbo GX via VRM Cloud API
- **Polling:** Every 3 minutes (VRM API rate limit: 50 requests/hour)
- **Metrics:** SOC, voltage, current, power, temperature, state (charging/discharging/idle)
- **Advantage:** Direct measurement from battery shunt, more accurate

### Hardware Setup
- **Device:** Victron Cerbo GX (battery monitor)
- **Connection:** Shunt connected to battery terminals + temperature sensor
- **Capability:** Read-only monitoring (NO control)
- **Cloud:** Connected to Victron VRM Cloud (Venus Remote Management)
- **API:** VRM REST API (https://vrmapi.victronenergy.com)

---

## 🏗️ Architecture Overview

```
┌─────────────────────────────────────────────────────┐
│  CommandCenter Backend (Railway)                    │
│  ┌──────────────────────────────────────────────┐   │
│  │  Victron Integration Module                  │   │
│  │  railway/src/integrations/victron.py         │   │
│  │  ┌────────────────────────────────────────┐  │   │
│  │  │ VRM API Client                         │  │   │
│  │  │ - Authenticate (login endpoint)        │  │   │
│  │  │ - Get installation list                │  │   │
│  │  │ - Fetch battery readings               │  │   │
│  │  └────────────────────────────────────────┘  │   │
│  └──────────────────┬───────────────────────────┘   │
│                     │                                │
│  ┌──────────────────▼───────────────────────────┐   │
│  │  Polling Service                             │   │
│  │  railway/src/services/victron_poller.py      │   │
│  │  - Background task (every 3 minutes)         │   │
│  │  - Error handling & retry logic              │   │
│  │  - Rate limit tracking                       │   │
│  └──────────────────┬───────────────────────────┘   │
│                     │                                │
│  ┌──────────────────▼───────────────────────────┐   │
│  │  Database: victron.battery_readings          │   │
│  │  - TimescaleDB hypertable                    │   │
│  │  - Time-series battery data                  │   │
│  │  - 72-hour retention (raw data)              │   │
│  └──────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
                      │
                      │ HTTPS
┌─────────────────────▼───────────────────────────────┐
│  Victron VRM Cloud API                              │
│  https://vrmapi.victronenergy.com                   │
│  - Rate Limit: 50 requests/hour                     │
│  - Authentication: Username + Password → Token      │
│  - Installation ID: Your Cerbo device               │
└─────────────────────────────────────────────────────┘
```

---

## 📋 Implementation Checklist

### Week 1, Day 1-2: VRM API Client (6-8 hours)

**File:** `railway/src/integrations/victron.py`

- [ ] **Create VictronVRMClient class**
  - [ ] `__init__()` - Store credentials, base URL
  - [ ] `authenticate()` - Login and get auth token
  - [ ] `get_installations()` - List all installations
  - [ ] `get_battery_data(installation_id)` - Fetch battery metrics
  - [ ] `_make_request()` - Generic HTTP request with retry logic
  - [ ] Error handling for API failures

- [ ] **Authentication Flow**
  ```python
  # POST to https://vrmapi.victronenergy.com/v2/auth/login
  # Body: {"username": "your-email", "password": "your-password"}
  # Response: {"token": "...", "idUser": 123}
  # Store token for subsequent requests
  ```

- [ ] **Fetch Battery Data**
  ```python
  # GET https://vrmapi.victronenergy.com/v2/installations/{id}/widgets/BatterySummary
  # Headers: {"X-Authorization": "Token {token}"}
  # Response: {
  #   "success": true,
  #   "records": {
  #     "voltage": 26.4,
  #     "current": 12.5,
  #     "soc": 67.0,
  #     "power": 330,
  #     "state": "charging",
  #     "temperature": 23.5
  #   }
  # }
  ```

- [ ] **Rate Limit Handling**
  - Track request count per hour
  - Raise error if approaching limit (45/50)
  - Log warnings at 40 requests

- [ ] **Unit Tests**
  - Mock API responses
  - Test authentication success/failure
  - Test rate limit tracking
  - Test error handling

**Acceptance Criteria:**
- ✅ Can authenticate to VRM API
- ✅ Can fetch installation list
- ✅ Can retrieve battery data
- ✅ Rate limit respected (max 20/hour with 3-min polling)
- ✅ All tests pass

---

### Week 1, Day 2-3: Database Schema & Migration (3-4 hours)

**File:** `railway/migrations/003_victron_schema.sql`

- [ ] **Create victron schema**
  ```sql
  CREATE SCHEMA IF NOT EXISTS victron;
  ```

- [ ] **Create battery_readings table**
  ```sql
  CREATE TABLE victron.battery_readings (
      id SERIAL PRIMARY KEY,
      timestamp TIMESTAMP DEFAULT NOW(),
      installation_id VARCHAR(100),  -- VRM installation ID

      -- Core metrics
      soc FLOAT NOT NULL,            -- State of charge (%)
      voltage FLOAT,                 -- Battery voltage (V)
      current FLOAT,                 -- Battery current (A, +charging/-discharging)
      power FLOAT,                   -- Battery power (W)

      -- State
      state VARCHAR(20),             -- 'charging', 'discharging', 'idle'

      -- Temperature
      temperature FLOAT,             -- Battery temperature (°C)

      -- Metadata
      created_at TIMESTAMP DEFAULT NOW()
  );
  ```

- [ ] **Create TimescaleDB hypertable**
  ```sql
  SELECT create_hypertable('victron.battery_readings', 'timestamp');
  ```

- [ ] **Create indexes**
  ```sql
  CREATE INDEX idx_battery_readings_timestamp
    ON victron.battery_readings(timestamp DESC);

  CREATE INDEX idx_battery_readings_installation
    ON victron.battery_readings(installation_id, timestamp DESC);
  ```

- [ ] **Add retention policy (72 hours)**
  ```sql
  SELECT add_retention_policy('victron.battery_readings', INTERVAL '72 hours');
  ```

- [ ] **Update schema initialization endpoint**
  - Add migration to `/db/init-schema` endpoint
  - Ensure idempotent execution

**Acceptance Criteria:**
- ✅ Schema migration runs successfully
- ✅ Hypertable created for time-series data
- ✅ Indexes improve query performance
- ✅ Retention policy auto-deletes old data
- ✅ No breaking changes to V1.5 tables

---

### Week 1, Day 3-4: Polling Service (4-5 hours)

**File:** `railway/src/services/victron_poller.py`

- [ ] **Create background polling service**
  ```python
  import asyncio
  from datetime import datetime
  from ..integrations.victron import VictronVRMClient
  from ..utils.db import get_db_connection

  class VictronPoller:
      def __init__(self):
          self.client = VictronVRMClient()
          self.installation_id = os.getenv("VICTRON_INSTALLATION_ID")
          self.poll_interval = 180  # 3 minutes

      async def start(self):
          """Start continuous polling"""
          while True:
              try:
                  await self.poll_and_store()
              except Exception as e:
                  logger.error(f"Polling error: {e}")

              await asyncio.sleep(self.poll_interval)

      async def poll_and_store(self):
          """Fetch data and store in database"""
          # Authenticate if needed
          # Fetch battery data
          # Insert into victron.battery_readings
          # Log success/failure
  ```

- [ ] **Error Handling**
  - API timeout (10 second timeout)
  - Network errors (retry 3 times with backoff)
  - Database errors (log and continue)
  - Authentication failures (re-authenticate)

- [ ] **Health Monitoring**
  - Track last successful poll timestamp
  - Alert if no successful poll in 10 minutes
  - Expose health via `/victron/health` endpoint

- [ ] **Integration with main app**
  - Start poller on application startup
  - Graceful shutdown on app stop

**Acceptance Criteria:**
- ✅ Polls every 3 minutes automatically
- ✅ Stores data in database successfully
- ✅ Handles errors without crashing
- ✅ Health check shows poller status
- ✅ Respects rate limits (20 requests/hour)

---

### Week 1, Day 4-5: API Endpoints (3-4 hours)

**File:** `railway/src/api/main.py` (add new routes)

- [ ] **GET /victron/battery/current** - Latest reading
  ```python
  @app.get("/victron/battery/current")
  async def get_current_battery():
      """
      Get latest Victron battery reading

      Returns:
          {
              "status": "success",
              "data": {
                  "timestamp": "2025-12-10T12:00:00Z",
                  "soc": 67.0,
                  "voltage": 26.4,
                  "current": 12.5,
                  "power": 330,
                  "state": "charging",
                  "temperature": 23.5
              }
          }
      """
  ```

- [ ] **GET /victron/battery/history** - Historical data
  ```python
  @app.get("/victron/battery/history")
  async def get_battery_history(
      hours: int = 24,
      limit: int = 100
  ):
      """
      Get historical battery readings

      Args:
          hours: Number of hours to look back (default 24)
          limit: Max number of records (default 100)

      Returns time-series data with timestamps
      """
  ```

- [ ] **GET /victron/health** - Service health
  ```python
  @app.get("/victron/health")
  async def get_victron_health():
      """
      Check Victron integration health

      Returns:
          {
              "status": "success",
              "data": {
                  "poller_running": true,
                  "last_poll": "2025-12-10T12:00:00Z",
                  "last_success": "2025-12-10T12:00:00Z",
                  "readings_count": 480,  # Last 24h
                  "api_calls_today": 18,
                  "rate_limit_remaining": 32
              }
          }
      """
  ```

**Acceptance Criteria:**
- ✅ All endpoints return correct data
- ✅ Error responses are meaningful
- ✅ OpenAPI docs updated automatically
- ✅ Response times < 200ms
- ✅ No breaking changes to V1.5 endpoints

---

### Week 1, Day 5: Agent Tool Integration (2-3 hours)

**File:** `railway/src/tools/victron_tools.py`

- [ ] **Create agent tool for battery data**
  ```python
  from crewai.tools import tool

  @tool("Get Victron Battery Status")
  def get_victron_battery_status() -> str:
      """
      Get accurate battery metrics from Victron Cerbo GX.

      Use this for:
      - Current battery state of charge (SOC)
      - Battery voltage and current
      - Charging/discharging state
      - Battery temperature

      Returns detailed battery information with timestamp.
      """
      # Fetch from /victron/battery/current endpoint
      # Format for agent consumption
      return formatted_battery_info
  ```

- [ ] **Update Solar Controller agent**
  - Add `get_victron_battery_status` to tools list
  - Update backstory to prefer Victron data for battery
  - Keep SolArk data for solar/load/grid

- [ ] **Update Energy Orchestrator agent**
  - Add `get_victron_battery_status` to tools list
  - Use Victron data for battery decisions
  - Combine with SolArk data for full picture

**Acceptance Criteria:**
- ✅ Agents can access Victron battery data
- ✅ Responses include accurate SOC, voltage, current
- ✅ No breaking changes to existing agent behavior
- ✅ Agents prefer Victron over SolArk for battery metrics

---

## 🔐 Environment Variables

### Required New Variables

Add to Railway backend service:

```bash
# Victron VRM API Credentials
VICTRON_VRM_USERNAME=your-email@example.com
VICTRON_VRM_PASSWORD=<secret-password>
VICTRON_INSTALLATION_ID=<your-installation-id>

# Optional: API Configuration
VICTRON_API_URL=https://vrmapi.victronenergy.com  # Default
VICTRON_POLL_INTERVAL=180  # 3 minutes (default)
```

### How to Get Installation ID

1. Log in to VRM Portal: https://vrm.victronenergy.com
2. Click on your installation
3. Look at URL: `https://vrm.victronenergy.com/installation/123456/dashboard`
4. Installation ID is `123456`

---

## 🧪 Testing Plan

### Unit Tests
- [ ] VRM API client authentication
- [ ] Battery data parsing
- [ ] Rate limit tracking
- [ ] Error handling

### Integration Tests
- [ ] End-to-end polling cycle
- [ ] Database storage
- [ ] API endpoint responses
- [ ] Agent tool usage

### Manual Testing
```bash
# 1. Test VRM API connection
curl -X POST http://localhost:8000/victron/test-connection

# 2. Trigger manual poll
curl -X POST http://localhost:8000/victron/poll-now

# 3. Check latest data
curl http://localhost:8000/victron/battery/current | jq

# 4. Check health
curl http://localhost:8000/victron/health | jq

# 5. Test agent query
curl -X POST http://localhost:8000/ask \
  -H "Content-Type: application/json" \
  -d '{"message": "What is my battery voltage and temperature?"}' | jq
```

### Production Validation
- [ ] Deploy to Railway
- [ ] Verify poller starts automatically
- [ ] Check data flowing to database
- [ ] Monitor rate limits (should stay under 20/hour)
- [ ] Test agent queries use Victron data
- [ ] Monitor for 24 hours without errors

---

## 📊 Success Criteria

### Minimum Requirements
- ✅ Victron data flows to database every 3 minutes
- ✅ API endpoints return accurate battery metrics
- ✅ Agents can access Victron battery data
- ✅ No V1.5 functionality broken
- ✅ Rate limits respected (< 40 requests/hour)

### Performance Targets
- ✅ API response time < 200ms
- ✅ Polling success rate > 98%
- ✅ Database queries < 50ms
- ✅ No memory leaks over 24 hours

### Data Quality
- ✅ SOC matches Victron display (within 1%)
- ✅ Voltage accurate to 0.1V
- ✅ Temperature readings valid
- ✅ No gaps > 5 minutes in data

---

## 🚨 Known Issues & Mitigations

### Issue 1: VRM API Rate Limits
**Problem:** 50 requests/hour limit, need 20 for 3-min polling
**Mitigation:**
- Poll every 3 minutes (20/hour)
- Track rate limit usage
- Alert if approaching limit
- Cache aggressively

### Issue 2: Authentication Token Expiration
**Problem:** VRM tokens expire after some time
**Mitigation:**
- Re-authenticate on 401 errors
- Proactive token refresh every 12 hours
- Log authentication failures

### Issue 3: Network Failures
**Problem:** Temporary connection issues to VRM cloud
**Mitigation:**
- Retry 3 times with exponential backoff
- Continue polling on failure (don't crash)
- Alert if failures > 10% over 1 hour

### Issue 4: Data Gaps
**Problem:** Missed polls create gaps in time-series
**Mitigation:**
- Log all poll failures
- Dashboard shows data age
- Agents note if data is stale (> 5 min old)

---

## 📚 Reference Documentation

### Victron VRM API
- **API Docs:** https://vrm-api-docs.victronenergy.com
- **VRM Portal:** https://vrm.victronenergy.com
- **Community:** https://community.victronenergy.com

### CommandCenter Docs
- **V2 Roadmap:** [V2_Roadmap.md](../V2_Roadmap.md)
- **Architecture:** [05-architecture.md](../05-architecture.md)
- **V1.5 Reference:** [V1.5_MASTER_REFERENCE.md](../V1.5_MASTER_REFERENCE.md)

### Related Files
- SolArk integration: `railway/src/integrations/solark.py`
- Database utils: `railway/src/utils/db.py`
- Agent tools: `railway/src/tools/`

---

## 🔄 Migration from V1.5

### Current State (V1.5)
```python
# Solar Controller uses SolArk for battery
battery_data = get_energy_status()  # From SolArk API
soc = battery_data['soc']
```

### Target State (V1.6)
```python
# Solar Controller uses Victron for battery
battery_data = get_victron_battery_status()  # From Victron
soc = battery_data['soc']  # More accurate!

# Still use SolArk for solar/load/grid
energy_data = get_energy_status()  # From SolArk API
solar = energy_data['pv_power']
```

### Compatibility
- Keep SolArk integration unchanged
- Agents use Victron for battery, SolArk for other metrics
- Dashboard can show both sources (comparison view)

---

## 🎯 Next Steps After Completion

Once Victron integration is working:

1. **Week 2: Shelly Integration** (per-device power monitoring)
2. **Week 2: Dashboard Updates** (show Victron vs SolArk comparison)
3. **Week 2: Data Retention** (implement hourly/daily aggregates)
4. **V1.7: Hardware Control** (use accurate battery data for control decisions)

---

## ✅ Definition of Done

**This task is complete when:**

- [ ] ✅ Victron VRM client implemented and tested
- [ ] ✅ Database schema migrated (victron.battery_readings)
- [ ] ✅ Polling service runs continuously every 3 minutes
- [ ] ✅ API endpoints return Victron data
- [ ] ✅ Agent tools access Victron battery metrics
- [ ] ✅ All tests pass (unit + integration)
- [ ] ✅ Deployed to production Railway
- [ ] ✅ 24-hour monitoring shows stability
- [ ] ✅ Documentation updated (API docs, architecture)
- [ ] ✅ No V1.5 functionality broken

---

**Prompt Ready for Implementation**

**Estimated Effort:** 15-20 hours (1 week, part-time)
**Complexity:** Medium (API integration + database + polling)
**Risk Level:** Low (read-only, no hardware control)
**Value:** High (foundation for all V2 features)

**To Start:** Copy this prompt to your AI assistant and begin with Day 1-2 (VRM API Client)
