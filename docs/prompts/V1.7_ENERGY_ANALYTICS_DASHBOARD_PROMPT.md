# V1.7 Energy Analytics Dashboard - Full Implementation Prompt

**Version:** V1.6 → V1.7
**Target:** Next.js Energy Dashboard (`vercel/src/app/energy/page.tsx`)
**Estimated Time:** 8-12 hours
**Priority:** High - Complete analytics suite for energy monitoring

---

## 🎯 Objective

Transform the V1.6 energy dashboard into a **comprehensive analytics platform** with historical trend charts, energy statistics, predictive analytics, cost tracking, and **excess energy monitoring**. This will combine Victron + SolArk data to provide actionable insights for optimizing solar energy usage and reducing costs.

**Why This Matters:**
- Historical trends reveal patterns in energy usage and production
- Statistics help identify inefficiencies and optimization opportunities
- Predictive analytics enable proactive energy management
- Cost tracking quantifies savings and ROI from solar investment
- **⚡ CRITICAL: Excess energy tracking identifies wasted solar power that could be harnessed for additional loads (miners, irrigation pumps, etc.)**

## 🔋 Excess Energy: The Key Metric

**Excess Energy = Total Solar Production - (Battery Charging + Load Consumption)**

This represents **LOST POWER** - solar energy that is being:
- Curtailed by the inverter (when batteries are full and no load exists)
- Exported to grid at low rates (when you could use it internally)
- Wasted potential that could power:
  - Bitcoin miners during high solar production
  - Irrigation pumps for ranch operations
  - Water heaters or other deferrable loads
  - Battery preconditioning or HVAC

**Business Impact:**
- Maximize ROI from solar investment
- Enable expansion of ranch operations without grid import
- Identify optimal times to run high-power equipment
- Reduce or eliminate grid export dependency

---

## 📚 Background Context

### Current State (V1.6)
- **Dashboard:** `vercel/src/app/energy/page.tsx`
- **Features:** Real-time power flow, dual-source battery comparison, health monitoring
- **Data Sources:**
  - SolArk API (system-level power flow)
  - Victron API (accurate battery metrics)
- **Limitations:** No historical visualization, no analytics, no cost tracking

### Target State (V1.7)
- **New Section:** Historical Trends with interactive charts
- **New Section:** Energy Statistics & Reports (daily/weekly/monthly)
- **New Section:** Predictive Analytics (SOC forecasting, solar production estimates)
- **New Section:** Cost Tracking (grid import/export costs, savings calculations)
- **⚡ NEW SECTION: Excess Energy Dashboard** (CRITICAL - tracks wasted solar power)
- **Enhanced:** Time range selector (6h, 12h, 24h, 48h, 72h, 7d, 30d)
- **Enhanced:** Export functionality (CSV, PDF reports)
- **Enhanced:** Load opportunity alerts (when to run miners, pumps, etc.)

---

## 🔌 Available API Endpoints

### SolArk Endpoints
```
GET /energy/latest
GET /energy/stats?hours=24
```

### Victron Endpoints
```
GET /victron/battery/current
GET /victron/battery/history?hours=24&limit=1000
GET /victron/health
```

### New Endpoints Needed (Backend Implementation Required)
```
GET /energy/history?hours=24&limit=1000
GET /energy/analytics/daily?days=30
GET /energy/analytics/cost?start_date=2025-01-01&end_date=2025-01-31
GET /energy/predictions/soc?hours=24
GET /energy/analytics/excess?hours=24          # ⚡ CRITICAL - Excess energy tracking
GET /energy/analytics/load-opportunities       # ⚡ CRITICAL - Optimal load scheduling
```

**Note:** If these endpoints don't exist, you'll need to implement them first in the FastAPI backend.

---

## 📋 Implementation Checklist

## PHASE 1: Backend API Endpoints (4-5 hours)

### Step 1.1: Energy History Endpoint

**File:** `railway/src/api/main.py`

Add endpoint to fetch historical energy data (SolArk + Victron combined):

```python
@app.get("/energy/history")
async def get_energy_history(
    hours: int = Query(default=24, ge=1, le=720),  # Max 30 days
    limit: int = Query(default=1000, ge=1, le=5000)
):
    """
    Get historical energy data combining SolArk and Victron sources.

    Returns time-series data with:
    - Solar production (SolArk)
    - Battery SOC (Victron + SolArk)
    - Load consumption (SolArk)
    - Grid import/export (SolArk)
    - Battery voltage, current, temperature (Victron)
    """
    try:
        from datetime import datetime, timedelta

        # Calculate time range
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)

        # Query database for SolArk data
        solark_data = db.query("""
            SELECT
                created_at as timestamp,
                solar_power as pv_power,
                battery_soc as soc,
                battery_power,
                load_power,
                grid_power
            FROM energy_data
            WHERE created_at >= %s AND created_at <= %s
            ORDER BY created_at ASC
            LIMIT %s
        """, (start_time, end_time, limit))

        # Query Victron data
        victron_data = db.query("""
            SELECT
                timestamp,
                soc as victron_soc,
                voltage,
                current,
                power as battery_power_victron,
                temperature,
                state
            FROM victron_battery_readings
            WHERE timestamp >= %s AND timestamp <= %s
            ORDER BY timestamp ASC
            LIMIT %s
        """, (start_time, end_time, limit))

        # Merge datasets by timestamp (align to nearest minute)
        merged_data = merge_timeseries(solark_data, victron_data)

        return {
            "status": "success",
            "hours": hours,
            "count": len(merged_data),
            "data": merged_data,
            "timestamp": time.time()
        }

    except Exception as e:
        logger.error(f"Error fetching energy history: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

### Step 1.2: Daily Analytics Endpoint

**File:** `railway/src/api/main.py`

Add endpoint for daily/weekly/monthly statistics:

```python
@app.get("/energy/analytics/daily")
async def get_daily_analytics(
    days: int = Query(default=30, ge=1, le=365)
):
    """
    Get daily aggregated energy statistics.

    Returns:
    - Total solar production per day
    - Average battery SOC per day
    - Total load consumption per day
    - Grid import/export totals
    - Peak power times
    - Efficiency metrics
    """
    try:
        from datetime import datetime, timedelta

        end_date = datetime.now().date()
        start_date = end_date - timedelta(days=days)

        # Query daily aggregates
        daily_stats = db.query("""
            SELECT
                DATE(created_at) as date,
                AVG(solar_power) as avg_solar,
                MAX(solar_power) as peak_solar,
                SUM(solar_power) / 60.0 as total_solar_kwh,  -- Assuming 1-min intervals
                AVG(battery_soc) as avg_soc,
                MIN(battery_soc) as min_soc,
                MAX(battery_soc) as max_soc,
                AVG(load_power) as avg_load,
                SUM(load_power) / 60.0 as total_load_kwh,
                AVG(battery_power) as avg_battery_power,
                SUM(CASE WHEN battery_power > 0 THEN battery_power ELSE 0 END) / 60.0 as battery_charging_kwh,
                SUM(CASE WHEN grid_power > 0 THEN grid_power ELSE 0 END) / 60.0 as grid_import_kwh,
                SUM(CASE WHEN grid_power < 0 THEN ABS(grid_power) ELSE 0 END) / 60.0 as grid_export_kwh,
                COUNT(*) as data_points
            FROM energy_data
            WHERE DATE(created_at) >= %s AND DATE(created_at) <= %s
            GROUP BY DATE(created_at)
            ORDER BY date DESC
        """, (start_date, end_date))

        # Calculate additional metrics including EXCESS ENERGY
        for day in daily_stats:
            # Solar self-consumption
            day['solar_self_consumption_pct'] = (
                (day['total_solar_kwh'] - day['grid_export_kwh']) / day['total_solar_kwh'] * 100
                if day['total_solar_kwh'] > 0 else 0
            )

            # Grid independence
            day['grid_independence_pct'] = (
                (day['total_load_kwh'] - day['grid_import_kwh']) / day['total_load_kwh'] * 100
                if day['total_load_kwh'] > 0 else 0
            )

            # ⚡ CRITICAL: Calculate EXCESS (WASTED) ENERGY
            # Excess = Solar Production - (Load + Battery Charging)
            # This is power that could have been used but wasn't
            solar_used = day['total_load_kwh'] + day['battery_charging_kwh']
            day['excess_energy_kwh'] = max(0, day['total_solar_kwh'] - solar_used)

            # Calculate excess as percentage of total solar
            day['excess_energy_pct'] = (
                day['excess_energy_kwh'] / day['total_solar_kwh'] * 100
                if day['total_solar_kwh'] > 0 else 0
            )

            # Potential revenue if excess was used for miners (assuming $0.05/kWh value)
            day['excess_value_usd'] = day['excess_energy_kwh'] * 0.05

        return {
            "status": "success",
            "days": days,
            "count": len(daily_stats),
            "data": daily_stats,
            "timestamp": time.time()
        }

    except Exception as e:
        logger.error(f"Error fetching daily analytics: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

### Step 1.3: Cost Tracking Endpoint

**File:** `railway/src/api/main.py`

Add endpoint for cost calculations:

```python
@app.get("/energy/analytics/cost")
async def get_cost_analytics(
    start_date: str = Query(..., description="Start date (YYYY-MM-DD)"),
    end_date: str = Query(..., description="End date (YYYY-MM-DD)"),
    import_rate: float = Query(default=0.12, description="Grid import rate ($/kWh)"),
    export_rate: float = Query(default=0.08, description="Grid export rate ($/kWh)")
):
    """
    Calculate energy costs and savings.

    Returns:
    - Grid import costs
    - Grid export revenue
    - Solar savings (avoided grid purchases)
    - Net savings
    - ROI metrics
    """
    try:
        from datetime import datetime

        start = datetime.strptime(start_date, "%Y-%m-%d")
        end = datetime.strptime(end_date, "%Y-%m-%d")

        # Query energy totals
        totals = db.query_one("""
            SELECT
                SUM(CASE WHEN grid_power > 0 THEN grid_power ELSE 0 END) / 60000.0 as grid_import_kwh,
                SUM(CASE WHEN grid_power < 0 THEN ABS(grid_power) ELSE 0 END) / 60000.0 as grid_export_kwh,
                SUM(solar_power) / 60000.0 as total_solar_kwh,
                SUM(load_power) / 60000.0 as total_load_kwh
            FROM energy_data
            WHERE created_at >= %s AND created_at <= %s
        """, (start, end))

        # Calculate costs
        grid_import_cost = totals['grid_import_kwh'] * import_rate
        grid_export_revenue = totals['grid_export_kwh'] * export_rate

        # Solar savings = solar used directly (not exported) * import rate
        solar_self_consumed = totals['total_solar_kwh'] - totals['grid_export_kwh']
        solar_savings = solar_self_consumed * import_rate

        net_savings = solar_savings + grid_export_revenue - grid_import_cost

        return {
            "status": "success",
            "period": {
                "start": start_date,
                "end": end_date,
                "days": (end - start).days + 1
            },
            "energy": {
                "solar_produced_kwh": round(totals['total_solar_kwh'], 2),
                "load_consumed_kwh": round(totals['total_load_kwh'], 2),
                "grid_import_kwh": round(totals['grid_import_kwh'], 2),
                "grid_export_kwh": round(totals['grid_export_kwh'], 2),
                "solar_self_consumed_kwh": round(solar_self_consumed, 2)
            },
            "costs": {
                "grid_import_cost": round(grid_import_cost, 2),
                "grid_export_revenue": round(grid_export_revenue, 2),
                "solar_savings": round(solar_savings, 2),
                "net_savings": round(net_savings, 2)
            },
            "rates": {
                "import_rate_per_kwh": import_rate,
                "export_rate_per_kwh": export_rate
            },
            "metrics": {
                "solar_self_consumption_pct": round(
                    solar_self_consumed / totals['total_solar_kwh'] * 100, 1
                ) if totals['total_solar_kwh'] > 0 else 0,
                "grid_independence_pct": round(
                    (totals['total_load_kwh'] - totals['grid_import_kwh']) / totals['total_load_kwh'] * 100, 1
                ) if totals['total_load_kwh'] > 0 else 0
            }
        }

    except Exception as e:
        logger.error(f"Error calculating costs: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

### Step 1.4: Predictive Analytics Endpoint

**File:** `railway/src/api/main.py`

Add endpoint for SOC and solar production predictions:

```python
@app.get("/energy/predictions/soc")
async def predict_battery_soc(
    hours: int = Query(default=24, ge=1, le=72, description="Hours to predict")
):
    """
    Predict future battery SOC based on:
    - Historical charge/discharge patterns
    - Time of day
    - Day of week
    - Recent solar production trends

    Uses simple linear regression + historical averages.
    For production: implement ML model with scikit-learn.
    """
    try:
        from datetime import datetime, timedelta
        import numpy as np

        # Get current SOC from Victron
        current_victron = await get_victron_battery_current()
        if current_victron['status'] != 'success':
            raise HTTPException(status_code=503, detail="Cannot get current battery data")

        current_soc = current_victron['data']['soc']
        current_time = datetime.now()

        # Get historical data for same time periods (last 7 days)
        historical_patterns = db.query("""
            SELECT
                EXTRACT(HOUR FROM created_at) as hour,
                EXTRACT(DOW FROM created_at) as day_of_week,
                AVG(battery_power) as avg_battery_power,
                AVG(solar_power) as avg_solar_power
            FROM energy_data
            WHERE created_at >= NOW() - INTERVAL '7 days'
            GROUP BY EXTRACT(HOUR FROM created_at), EXTRACT(DOW FROM created_at)
        """)

        # Simple prediction: current SOC + estimated charge/discharge
        predictions = []
        predicted_soc = current_soc

        for h in range(hours):
            future_time = current_time + timedelta(hours=h)
            hour = future_time.hour
            dow = future_time.weekday()

            # Find historical average for this hour/day
            pattern = next((p for p in historical_patterns
                          if p['hour'] == hour and p['day_of_week'] == dow), None)

            if pattern:
                # Estimate SOC change based on historical battery power
                # Assuming 10kWh battery capacity
                battery_capacity_wh = 10000
                avg_power = pattern['avg_battery_power']
                soc_change = (avg_power / battery_capacity_wh) * 100  # % change per hour
                predicted_soc = max(0, min(100, predicted_soc + soc_change))

            predictions.append({
                "timestamp": future_time.isoformat(),
                "hour": hour,
                "predicted_soc": round(predicted_soc, 1),
                "confidence": "medium" if pattern else "low"
            })

        return {
            "status": "success",
            "current_soc": round(current_soc, 1),
            "prediction_hours": hours,
            "predictions": predictions,
            "model": "historical_average",
            "note": "Predictions based on 7-day historical patterns. Actual results may vary based on weather and usage."
        }

    except Exception as e:
        logger.error(f"Error predicting SOC: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

### Step 1.5: Excess Energy Tracking Endpoint ⚡ CRITICAL

**File:** `railway/src/api/main.py`

Add endpoint to track and analyze excess (wasted) solar energy:

```python
@app.get("/energy/analytics/excess")
async def get_excess_energy_analytics(
    hours: int = Query(default=24, ge=1, le=168, description="Hours to analyze")
):
    """
    ⚡ CRITICAL ENDPOINT: Track excess (wasted) solar energy.

    Excess Energy = Solar Production - (Load Consumption + Battery Charging)

    This represents lost opportunity to:
    - Run Bitcoin miners during peak solar
    - Operate irrigation pumps
    - Power water heaters or HVAC
    - Pre-cool/heat buildings
    - Charge electric vehicles

    Returns:
    - Time-series of excess power
    - Total excess energy (kWh)
    - Peak excess power times
    - Potential value if harnessed
    - Load opportunity recommendations
    """
    try:
        from datetime import datetime, timedelta

        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)

        # Query energy data with excess calculation
        excess_data = db.query("""
            SELECT
                created_at as timestamp,
                solar_power as pv_power,
                load_power,
                battery_power,
                battery_soc,
                -- Calculate excess power in real-time
                CASE
                    WHEN solar_power > (load_power + CASE WHEN battery_power > 0 THEN battery_power ELSE 0 END)
                    THEN solar_power - (load_power + CASE WHEN battery_power > 0 THEN battery_power ELSE 0 END)
                    ELSE 0
                END as excess_power
            FROM energy_data
            WHERE created_at >= %s AND created_at <= %s
            ORDER BY created_at ASC
        """, (start_time, end_time))

        # Calculate summary metrics
        total_excess_kwh = sum(row['excess_power'] for row in excess_data) / 60000.0  # Convert W·min to kWh
        avg_excess_power = sum(row['excess_power'] for row in excess_data) / len(excess_data) if excess_data else 0
        peak_excess_power = max(row['excess_power'] for row in excess_data) if excess_data else 0

        # Find peak excess times (when we're wasting the most power)
        peak_excess_times = [
            {
                "timestamp": row['timestamp'],
                "excess_power": row['excess_power'],
                "battery_soc": row['battery_soc']
            }
            for row in sorted(excess_data, key=lambda x: x['excess_power'], reverse=True)[:10]
        ]

        # Calculate potential value
        # Assume $0.05/kWh value if used for miners or pumps
        potential_value = total_excess_kwh * 0.05

        # Calculate hourly patterns (which hours have most excess)
        hourly_excess = {}
        for row in excess_data:
            hour = row['timestamp'].hour
            if hour not in hourly_excess:
                hourly_excess[hour] = []
            hourly_excess[hour].append(row['excess_power'])

        hourly_avg = {
            hour: sum(powers) / len(powers)
            for hour, powers in hourly_excess.items()
        }

        # Find best hours to run heavy loads
        best_load_hours = sorted(hourly_avg.items(), key=lambda x: x[1], reverse=True)[:5]

        return {
            "status": "success",
            "period": {
                "hours": hours,
                "start": start_time.isoformat(),
                "end": end_time.isoformat()
            },
            "summary": {
                "total_excess_kwh": round(total_excess_kwh, 2),
                "avg_excess_power_w": round(avg_excess_power, 0),
                "peak_excess_power_w": round(peak_excess_power, 0),
                "potential_value_usd": round(potential_value, 2),
                "data_points": len(excess_data)
            },
            "time_series": [
                {
                    "timestamp": row['timestamp'].isoformat(),
                    "excess_power": round(row['excess_power'], 0),
                    "battery_soc": round(row['battery_soc'], 1)
                }
                for row in excess_data[::5]  # Downsample for performance
            ],
            "peak_excess_times": peak_excess_times,
            "hourly_patterns": {
                str(hour): round(avg, 0)
                for hour, avg in sorted(hourly_avg.items())
            },
            "recommendations": {
                "best_load_hours": [
                    {
                        "hour": f"{hour:02d}:00",
                        "avg_excess_w": round(avg, 0),
                        "potential_kwh_daily": round(avg / 1000, 2)
                    }
                    for hour, avg in best_load_hours
                ],
                "suggested_actions": generate_excess_recommendations(total_excess_kwh, peak_excess_power, best_load_hours)
            }
        }

    except Exception as e:
        logger.error(f"Error analyzing excess energy: {e}")
        raise HTTPException(status_code=500, detail=str(e))


def generate_excess_recommendations(total_kwh, peak_power, best_hours):
    """Generate actionable recommendations for excess energy usage."""
    recommendations = []

    if total_kwh > 5:
        recommendations.append({
            "priority": "high",
            "action": "Deploy Bitcoin Miners",
            "details": f"You have {total_kwh:.1f} kWh/day of excess energy. This could power ~{int(total_kwh * 20)} TH/s of mining hashrate.",
            "potential_revenue": f"${(total_kwh * 0.05):.2f}/day"
        })

    if peak_power > 2000:
        recommendations.append({
            "priority": "medium",
            "action": "Schedule Irrigation",
            "details": f"Peak excess power is {peak_power:.0f}W. Run irrigation pumps during hours: {', '.join(str(h[0]) for h in best_hours[:3])}",
            "potential_savings": "Avoid grid import costs"
        })

    if total_kwh > 10:
        recommendations.append({
            "priority": "medium",
            "action": "Pre-heat Water",
            "details": f"Excess energy could heat water during {', '.join(str(h[0]) for h in best_hours[:2])}, reducing evening grid usage",
            "potential_savings": "~$30/month on water heating"
        })

    if len(best_hours) > 0 and best_hours[0][1] > 1000:
        recommendations.append({
            "priority": "low",
            "action": "EV Charging Optimization",
            "details": f"Best charging window: {best_hours[0][0]}:00-{best_hours[0][0]+2}:00 when excess averages {best_hours[0][1]:.0f}W",
            "potential_savings": "100% solar charging"
        })

    return recommendations
```

### Step 1.6: Load Opportunity Detection Endpoint ⚡ CRITICAL

**File:** `railway/src/api/main.py`

Add endpoint to identify optimal times to run discretionary loads:

```python
@app.get("/energy/analytics/load-opportunities")
async def get_load_opportunities():
    """
    ⚡ CRITICAL: Identify optimal times to run discretionary loads.

    Analyzes:
    - Battery SOC levels
    - Solar production forecasts (based on historical patterns)
    - Current excess energy
    - Grid import/export status

    Returns real-time recommendations for:
    - Bitcoin miner operations
    - Irrigation pump scheduling
    - Water heater activation
    - HVAC preconditioning
    - Other deferrable loads
    """
    try:
        from datetime import datetime, timedelta

        current_time = datetime.now()

        # Get current system status
        current_data = db.query_one("""
            SELECT
                solar_power,
                load_power,
                battery_power,
                battery_soc,
                grid_power,
                created_at
            FROM energy_data
            ORDER BY created_at DESC
            LIMIT 1
        """)

        if not current_data:
            raise HTTPException(status_code=404, detail="No current energy data available")

        # Calculate current excess
        battery_charging = max(0, current_data['battery_power'])
        current_excess = max(0, current_data['solar_power'] - (current_data['load_power'] + battery_charging))

        # Get historical solar production for next few hours (7-day avg)
        hour_now = current_time.hour
        forecast = []

        for h in range(6):  # Next 6 hours
            future_hour = (hour_now + h) % 24
            avg_solar = db.query_one("""
                SELECT AVG(solar_power) as avg_power
                FROM energy_data
                WHERE EXTRACT(HOUR FROM created_at) = %s
                  AND created_at >= NOW() - INTERVAL '7 days'
            """, (future_hour,))

            forecast.append({
                "hour": future_hour,
                "predicted_solar_w": round(avg_solar['avg_power'], 0) if avg_solar else 0
            })

        # Determine load opportunities
        opportunities = []

        # Opportunity 1: Run miners NOW if excess > 1000W
        if current_excess > 1000:
            opportunities.append({
                "type": "immediate",
                "load": "Bitcoin Miners",
                "action": "START",
                "power_available": round(current_excess, 0),
                "reason": f"Current excess: {current_excess:.0f}W available for immediate use",
                "priority": "high",
                "duration_estimate": "Until solar production drops or battery needs charging"
            })

        # Opportunity 2: Run irrigation if SOC > 80% and solar > 3kW
        if current_data['battery_soc'] > 80 and current_data['solar_power'] > 3000:
            opportunities.append({
                "type": "immediate",
                "load": "Irrigation Pumps",
                "action": "START",
                "power_available": round(current_data['solar_power'] - current_data['load_power'], 0),
                "reason": f"Battery well charged ({current_data['battery_soc']:.1f}%), high solar production",
                "priority": "medium",
                "duration_estimate": "2-3 hours while sun is high"
            })

        # Opportunity 3: Pre-heat water if excess and SOC > 70%
        if current_excess > 500 and current_data['battery_soc'] > 70:
            opportunities.append({
                "type": "immediate",
                "load": "Water Heater",
                "action": "START",
                "power_available": round(min(current_excess, 1500), 0),  # Typical water heater
                "reason": "Excess solar available, store energy as hot water",
                "priority": "low",
                "duration_estimate": "30-60 minutes"
            })

        # Opportunity 4: Schedule loads for upcoming peak hours
        peak_solar_hour = max(forecast, key=lambda x: x['predicted_solar_w'])
        if peak_solar_hour['predicted_solar_w'] > 4000:
            opportunities.append({
                "type": "scheduled",
                "load": "Heavy Loads (Miners, Pumps, etc.)",
                "action": "SCHEDULE",
                "scheduled_time": f"{peak_solar_hour['hour']:02d}:00",
                "power_available": round(peak_solar_hour['predicted_solar_w'] * 0.7, 0),  # Conservative estimate
                "reason": f"Peak solar production expected at {peak_solar_hour['hour']:02d}:00",
                "priority": "medium",
                "duration_estimate": "1-2 hours during peak production"
            })

        # Opportunity 5: Avoid loads if battery low and no solar
        if current_data['battery_soc'] < 30 and current_data['solar_power'] < 500:
            opportunities.append({
                "type": "warning",
                "load": "All Discretionary Loads",
                "action": "STOP",
                "power_available": 0,
                "reason": f"Low battery ({current_data['battery_soc']:.1f}%), minimal solar production",
                "priority": "high",
                "duration_estimate": "Until battery recharged or solar production increases"
            })

        return {
            "status": "success",
            "timestamp": current_time.isoformat(),
            "current_status": {
                "solar_power_w": round(current_data['solar_power'], 0),
                "load_power_w": round(current_data['load_power'], 0),
                "battery_soc_pct": round(current_data['battery_soc'], 1),
                "excess_power_w": round(current_excess, 0),
                "grid_power_w": round(current_data['grid_power'], 0)
            },
            "solar_forecast_6h": forecast,
            "opportunities": opportunities,
            "summary": {
                "total_opportunities": len(opportunities),
                "immediate_actions": len([o for o in opportunities if o['type'] == 'immediate']),
                "scheduled_actions": len([o for o in opportunities if o['type'] == 'scheduled']),
                "warnings": len([o for o in opportunities if o['type'] == 'warning'])
            }
        }

    except Exception as e:
        logger.error(f"Error detecting load opportunities: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

**Acceptance Criteria (Backend):**
- ✅ All 6 new endpoints implemented (including 2 excess energy endpoints)
- ✅ Excess energy calculations accurate
- ✅ Load opportunity logic triggers correctly
- ✅ Proper error handling and logging
- ✅ Query performance optimized (< 2 seconds)
- ✅ Documentation added to API docs
- ✅ Test endpoints with Postman/curl

---

## PHASE 2: Frontend Dashboard Components (4-6 hours)

### Step 2.1: Install Required Dependencies

**File:** `vercel/package.json`

Add chart libraries:

```bash
npm install recharts date-fns
npm install --save-dev @types/recharts
```

**Recharts** is preferred over Plotly for React/Next.js for:
- Better TypeScript support
- Native React components
- Smaller bundle size
- Better Next.js integration

### Step 2.2: Create Chart Components

**File:** `vercel/src/components/energy/HistoricalCharts.tsx`

Create reusable chart components:

```tsx
'use client'

import { LineChart, Line, AreaChart, Area, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'
import { format } from 'date-fns'

interface HistoricalDataPoint {
  timestamp: string
  pv_power?: number
  battery_power?: number
  load_power?: number
  grid_power?: number
  soc?: number
  victron_soc?: number
  voltage?: number
  current?: number
  temperature?: number
}

interface HistoricalChartsProps {
  data: HistoricalDataPoint[]
  timeRange: string
}

export function PowerFlowChart({ data }: { data: HistoricalDataPoint[] }) {
  const chartData = data.map(d => ({
    time: format(new Date(d.timestamp), 'HH:mm'),
    solar: d.pv_power || 0,
    load: d.load_power || 0,
    battery: Math.abs(d.battery_power || 0),
    grid: Math.abs(d.grid_power || 0)
  }))

  return (
    <ResponsiveContainer width="100%" height={300}>
      <AreaChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
        <XAxis
          dataKey="time"
          tick={{ fontSize: 12 }}
          interval="preserveStartEnd"
        />
        <YAxis
          label={{ value: 'Power (W)', angle: -90, position: 'insideLeft' }}
          tick={{ fontSize: 12 }}
        />
        <Tooltip
          contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
          formatter={(value: number) => `${value.toLocaleString()}W`}
        />
        <Legend />
        <Area
          type="monotone"
          dataKey="solar"
          stackId="1"
          stroke="#f59e0b"
          fill="#fef3c7"
          name="Solar"
        />
        <Area
          type="monotone"
          dataKey="battery"
          stackId="2"
          stroke="#10b981"
          fill="#d1fae5"
          name="Battery"
        />
        <Area
          type="monotone"
          dataKey="load"
          stackId="3"
          stroke="#3b82f6"
          fill="#dbeafe"
          name="Load"
        />
      </AreaChart>
    </ResponsiveContainer>
  )
}

export function SOCComparisonChart({ data }: { data: HistoricalDataPoint[] }) {
  const chartData = data
    .filter(d => d.victron_soc !== undefined)
    .map(d => ({
      time: format(new Date(d.timestamp), 'HH:mm'),
      victron: d.victron_soc,
      solark: d.soc,
      difference: Math.abs((d.victron_soc || 0) - (d.soc || 0))
    }))

  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
        <XAxis
          dataKey="time"
          tick={{ fontSize: 12 }}
          interval="preserveStartEnd"
        />
        <YAxis
          label={{ value: 'SOC (%)', angle: -90, position: 'insideLeft' }}
          tick={{ fontSize: 12 }}
          domain={[0, 100]}
        />
        <Tooltip
          contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
          formatter={(value: number) => `${value.toFixed(1)}%`}
        />
        <Legend />
        <Line
          type="monotone"
          dataKey="victron"
          stroke="#3b82f6"
          strokeWidth={2}
          dot={false}
          name="Victron (Accurate)"
        />
        <Line
          type="monotone"
          dataKey="solark"
          stroke="#94a3b8"
          strokeWidth={2}
          dot={false}
          strokeDasharray="5 5"
          name="SolArk (Estimated)"
        />
      </LineChart>
    </ResponsiveContainer>
  )
}

export function BatteryVoltageChart({ data }: { data: HistoricalDataPoint[] }) {
  const chartData = data
    .filter(d => d.voltage !== undefined)
    .map(d => ({
      time: format(new Date(d.timestamp), 'HH:mm'),
      voltage: d.voltage
    }))

  return (
    <ResponsiveContainer width="100%" height={250}>
      <LineChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
        <XAxis
          dataKey="time"
          tick={{ fontSize: 12 }}
          interval="preserveStartEnd"
        />
        <YAxis
          label={{ value: 'Voltage (V)', angle: -90, position: 'insideLeft' }}
          tick={{ fontSize: 12 }}
          domain={[48, 58]}
        />
        <Tooltip
          contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
          formatter={(value: number) => `${value.toFixed(2)}V`}
        />
        {/* Safe voltage range indicator */}
        <Area
          type="monotone"
          dataKey="voltage"
          stroke="#3b82f6"
          fill="#dbeafe"
          strokeWidth={2}
        />
      </LineChart>
    </ResponsiveContainer>
  )
}

export function BatteryCurrentChart({ data }: { data: HistoricalDataPoint[] }) {
  const chartData = data
    .filter(d => d.current !== undefined)
    .map(d => ({
      time: format(new Date(d.timestamp), 'HH:mm'),
      current: d.current,
      charging: d.current > 0 ? d.current : 0,
      discharging: d.current < 0 ? Math.abs(d.current) : 0
    }))

  return (
    <ResponsiveContainer width="100%" height={250}>
      <AreaChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
        <XAxis
          dataKey="time"
          tick={{ fontSize: 12 }}
          interval="preserveStartEnd"
        />
        <YAxis
          label={{ value: 'Current (A)', angle: -90, position: 'insideLeft' }}
          tick={{ fontSize: 12 }}
        />
        <Tooltip
          contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
          formatter={(value: number) => `${value.toFixed(1)}A`}
        />
        <Legend />
        <Area
          type="monotone"
          dataKey="charging"
          stackId="1"
          stroke="#22c55e"
          fill="#bbf7d0"
          name="Charging"
        />
        <Area
          type="monotone"
          dataKey="discharging"
          stackId="2"
          stroke="#ef4444"
          fill="#fecaca"
          name="Discharging"
        />
      </AreaChart>
    </ResponsiveContainer>
  )
}

export function TemperatureChart({ data }: { data: HistoricalDataPoint[] }) {
  const chartData = data
    .filter(d => d.temperature !== undefined)
    .map(d => ({
      time: format(new Date(d.timestamp), 'HH:mm'),
      temperature: d.temperature,
      tempF: (d.temperature * 9/5) + 32
    }))

  return (
    <ResponsiveContainer width="100%" height={250}>
      <LineChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
        <XAxis
          dataKey="time"
          tick={{ fontSize: 12 }}
          interval="preserveStartEnd"
        />
        <YAxis
          label={{ value: 'Temperature (°C)', angle: -90, position: 'insideLeft' }}
          tick={{ fontSize: 12 }}
        />
        <Tooltip
          contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
          formatter={(value: number, name: string) => [
            name === 'temperature' ? `${value.toFixed(1)}°C` : `${value.toFixed(1)}°F`,
            name === 'temperature' ? 'Celsius' : 'Fahrenheit'
          ]}
        />
        <Line
          type="monotone"
          dataKey="temperature"
          stroke="#f59e0b"
          strokeWidth={2}
          dot={false}
        />
      </LineChart>
    </ResponsiveContainer>
  )
}
```

### Step 2.3: Create Analytics Dashboard Components

**File:** `vercel/src/components/energy/EnergyStatistics.tsx`

```tsx
'use client'

import { TrendingUp, TrendingDown, Zap, DollarSign, Battery, Sun } from 'lucide-react'

interface DailyStats {
  date: string
  avg_solar: number
  peak_solar: number
  total_solar_kwh: number
  avg_soc: number
  min_soc: number
  max_soc: number
  avg_load: number
  total_load_kwh: number
  battery_charging_kwh: number
  grid_import_kwh: number
  grid_export_kwh: number
  solar_self_consumption_pct: number
  grid_independence_pct: number
  excess_energy_kwh: number        // ⚡ CRITICAL - wasted solar power
  excess_energy_pct: number         // ⚡ % of solar that was wasted
  excess_value_usd: number          // ⚡ Potential value if harnessed
}

interface EnergyStatisticsProps {
  dailyStats: DailyStats[]
  period: 'week' | 'month' | 'year'
}

export function EnergyStatistics({ dailyStats, period }: EnergyStatisticsProps) {
  if (!dailyStats || dailyStats.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        No statistics available for this period
      </div>
    )
  }

  // Calculate totals and averages
  const totals = {
    solar_kwh: dailyStats.reduce((sum, d) => sum + d.total_solar_kwh, 0),
    load_kwh: dailyStats.reduce((sum, d) => sum + d.total_load_kwh, 0),
    grid_import_kwh: dailyStats.reduce((sum, d) => sum + d.grid_import_kwh, 0),
    grid_export_kwh: dailyStats.reduce((sum, d) => sum + d.grid_export_kwh, 0),
    excess_kwh: dailyStats.reduce((sum, d) => sum + d.excess_energy_kwh, 0),         // ⚡ CRITICAL
    excess_value: dailyStats.reduce((sum, d) => sum + d.excess_value_usd, 0),       // ⚡ CRITICAL
  }

  const averages = {
    solar_self_consumption: dailyStats.reduce((sum, d) => sum + d.solar_self_consumption_pct, 0) / dailyStats.length,
    grid_independence: dailyStats.reduce((sum, d) => sum + d.grid_independence_pct, 0) / dailyStats.length,
    soc: dailyStats.reduce((sum, d) => sum + d.avg_soc, 0) / dailyStats.length,
    peak_solar: Math.max(...dailyStats.map(d => d.peak_solar)),
    excess_pct: dailyStats.reduce((sum, d) => sum + d.excess_energy_pct, 0) / dailyStats.length,  // ⚡ CRITICAL
  }

  return (
    <div className="space-y-6">
      {/* ⚡ CRITICAL: Excess Energy Alert */}
      {totals.excess_kwh > 1 && (
        <div className="bg-gradient-to-r from-orange-50 to-red-50 border-2 border-orange-400 rounded-lg p-6">
          <div className="flex items-start gap-4">
            <div className="flex-shrink-0">
              <Zap className="w-10 h-10 text-orange-600" />
            </div>
            <div className="flex-1">
              <h3 className="text-xl font-bold text-orange-900 mb-2">
                ⚠️ WASTED SOLAR ENERGY DETECTED
              </h3>
              <p className="text-orange-800 mb-3">
                You're losing <strong>{totals.excess_kwh.toFixed(1)} kWh</strong> ({averages.excess_pct.toFixed(1)}%) of solar production!
                This excess energy could power additional loads like Bitcoin miners, irrigation pumps, or water heaters.
              </p>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
                <div className="bg-white rounded p-3 border border-orange-200">
                  <p className="text-sm text-gray-600">Wasted Energy</p>
                  <p className="text-2xl font-bold text-orange-600">{totals.excess_kwh.toFixed(1)} kWh</p>
                </div>
                <div className="bg-white rounded p-3 border border-orange-200">
                  <p className="text-sm text-gray-600">Potential Value</p>
                  <p className="text-2xl font-bold text-green-600">${totals.excess_value.toFixed(2)}</p>
                </div>
                <div className="bg-white rounded p-3 border border-orange-200">
                  <p className="text-sm text-gray-600">Mining Potential</p>
                  <p className="text-2xl font-bold text-blue-600">{(totals.excess_kwh * 20).toFixed(0)} TH/s</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          icon={<Sun className="w-6 h-6 text-yellow-600" />}
          title="Total Solar Production"
          value={`${totals.solar_kwh.toFixed(1)} kWh`}
          subtitle={`Peak: ${averages.peak_solar.toFixed(0)}W`}
          trend="+12%"
          trendUp={true}
        />

        <StatCard
          icon={<Battery className="w-6 h-6 text-green-600" />}
          title="Avg Battery SOC"
          value={`${averages.soc.toFixed(1)}%`}
          subtitle="Average state of charge"
          trend="+5%"
          trendUp={true}
        />

        <StatCard
          icon={<Zap className="w-6 h-6 text-blue-600" />}
          title="Total Load"
          value={`${totals.load_kwh.toFixed(1)} kWh`}
          subtitle={`Avg: ${(totals.load_kwh / dailyStats.length).toFixed(1)} kWh/day`}
        />

        <StatCard
          icon={<TrendingUp className="w-6 h-6 text-purple-600" />}
          title="Grid Independence"
          value={`${averages.grid_independence.toFixed(1)}%`}
          subtitle="Self-sufficiency ratio"
          trend="+8%"
          trendUp={true}
        />
      </div>

      {/* Efficiency Metrics */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">Efficiency Metrics</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <EfficiencyBar
            label="Solar Self-Consumption"
            percentage={averages.solar_self_consumption}
            color="bg-yellow-500"
            description="% of solar energy used directly (not exported)"
          />

          <EfficiencyBar
            label="Grid Independence"
            percentage={averages.grid_independence}
            color="bg-green-500"
            description="% of load met by solar + battery (not grid)"
          />
        </div>
      </div>

      {/* Daily Breakdown Table */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">Daily Breakdown</h3>
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-gray-50 border-b border-gray-200">
              <tr>
                <th className="px-4 py-2 text-left">Date</th>
                <th className="px-4 py-2 text-right">Solar (kWh)</th>
                <th className="px-4 py-2 text-right">Load (kWh)</th>
                <th className="px-4 py-2 text-right">Import (kWh)</th>
                <th className="px-4 py-2 text-right">Export (kWh)</th>
                <th className="px-4 py-2 text-right">Avg SOC</th>
              </tr>
            </thead>
            <tbody>
              {dailyStats.slice(0, 10).map((day, idx) => (
                <tr key={idx} className="border-b border-gray-100 hover:bg-gray-50">
                  <td className="px-4 py-2">{new Date(day.date).toLocaleDateString()}</td>
                  <td className="px-4 py-2 text-right">{day.total_solar_kwh.toFixed(1)}</td>
                  <td className="px-4 py-2 text-right">{day.total_load_kwh.toFixed(1)}</td>
                  <td className="px-4 py-2 text-right text-orange-600">{day.grid_import_kwh.toFixed(1)}</td>
                  <td className="px-4 py-2 text-right text-green-600">{day.grid_export_kwh.toFixed(1)}</td>
                  <td className="px-4 py-2 text-right">{day.avg_soc.toFixed(1)}%</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  )
}

function StatCard({
  icon,
  title,
  value,
  subtitle,
  trend,
  trendUp
}: {
  icon: React.ReactNode
  title: string
  value: string
  subtitle?: string
  trend?: string
  trendUp?: boolean
}) {
  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            {icon}
            <p className="text-sm text-gray-600">{title}</p>
          </div>
          <p className="text-2xl font-bold text-gray-900">{value}</p>
          {subtitle && (
            <p className="text-xs text-gray-500 mt-1">{subtitle}</p>
          )}
        </div>
        {trend && (
          <div className={`flex items-center gap-1 text-xs font-medium ${trendUp ? 'text-green-600' : 'text-red-600'}`}>
            {trendUp ? <TrendingUp className="w-3 h-3" /> : <TrendingDown className="w-3 h-3" />}
            {trend}
          </div>
        )}
      </div>
    </div>
  )
}

function EfficiencyBar({
  label,
  percentage,
  color,
  description
}: {
  label: string
  percentage: number
  color: string
  description: string
}) {
  return (
    <div>
      <div className="flex justify-between items-center mb-2">
        <span className="text-sm font-medium text-gray-900">{label}</span>
        <span className="text-sm font-bold text-gray-900">{percentage.toFixed(1)}%</span>
      </div>
      <div className="w-full bg-gray-200 rounded-full h-3">
        <div
          className={`${color} h-3 rounded-full transition-all duration-500`}
          style={{ width: `${percentage}%` }}
        />
      </div>
      <p className="text-xs text-gray-500 mt-1">{description}</p>
    </div>
  )
}
```

### Step 2.4: Create Cost Tracking Component

**File:** `vercel/src/components/energy/CostTracking.tsx`

```tsx
'use client'

import { DollarSign, TrendingDown, TrendingUp, PiggyBank, Zap } from 'lucide-react'
import { useState } from 'react'

interface CostData {
  period: {
    start: string
    end: string
    days: number
  }
  energy: {
    solar_produced_kwh: number
    load_consumed_kwh: number
    grid_import_kwh: number
    grid_export_kwh: number
    solar_self_consumed_kwh: number
  }
  costs: {
    grid_import_cost: number
    grid_export_revenue: number
    solar_savings: number
    net_savings: number
  }
  rates: {
    import_rate_per_kwh: number
    export_rate_per_kwh: number
  }
  metrics: {
    solar_self_consumption_pct: number
    grid_independence_pct: number
  }
}

interface CostTrackingProps {
  costData: CostData | null
  loading: boolean
}

export function CostTracking({ costData, loading }: CostTrackingProps) {
  const [importRate, setImportRate] = useState(0.12)
  const [exportRate, setExportRate] = useState(0.08)

  if (loading) {
    return (
      <div className="text-center py-8 text-gray-500">
        Loading cost data...
      </div>
    )
  }

  if (!costData) {
    return (
      <div className="text-center py-8 text-gray-500">
        No cost data available
      </div>
    )
  }

  const { energy, costs, metrics } = costData

  return (
    <div className="space-y-6">
      {/* Rate Configuration */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h3 className="text-sm font-semibold text-blue-900 mb-3">Configure Energy Rates</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="text-xs text-blue-800 block mb-1">Grid Import Rate ($/kWh)</label>
            <input
              type="number"
              step="0.01"
              value={importRate}
              onChange={(e) => setImportRate(parseFloat(e.target.value))}
              className="w-full px-3 py-2 border border-blue-300 rounded text-sm"
            />
          </div>
          <div>
            <label className="text-xs text-blue-800 block mb-1">Grid Export Rate ($/kWh)</label>
            <input
              type="number"
              step="0.01"
              value={exportRate}
              onChange={(e) => setExportRate(parseFloat(e.target.value))}
              className="w-full px-3 py-2 border border-blue-300 rounded text-sm"
            />
          </div>
        </div>
      </div>

      {/* Cost Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <CostCard
          icon={<TrendingDown className="w-6 h-6 text-red-600" />}
          title="Grid Import Cost"
          value={`$${costs.grid_import_cost.toFixed(2)}`}
          subtitle={`${energy.grid_import_kwh.toFixed(1)} kWh @ $${importRate}/kWh`}
          color="text-red-600"
        />

        <CostCard
          icon={<TrendingUp className="w-6 h-6 text-green-600" />}
          title="Export Revenue"
          value={`$${costs.grid_export_revenue.toFixed(2)}`}
          subtitle={`${energy.grid_export_kwh.toFixed(1)} kWh @ $${exportRate}/kWh`}
          color="text-green-600"
        />

        <CostCard
          icon={<PiggyBank className="w-6 h-6 text-blue-600" />}
          title="Solar Savings"
          value={`$${costs.solar_savings.toFixed(2)}`}
          subtitle={`${energy.solar_self_consumed_kwh.toFixed(1)} kWh self-consumed`}
          color="text-blue-600"
        />

        <CostCard
          icon={<DollarSign className="w-6 h-6 text-purple-600" />}
          title="Net Savings"
          value={`$${costs.net_savings.toFixed(2)}`}
          subtitle="Total savings this period"
          color="text-purple-600"
          highlight={true}
        />
      </div>

      {/* Energy Flow Breakdown */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">Energy Flow Breakdown</h3>
        <div className="space-y-4">
          <EnergyFlowBar
            label="Solar Produced"
            value={energy.solar_produced_kwh}
            total={energy.solar_produced_kwh}
            color="bg-yellow-500"
            icon={<Zap className="w-4 h-4" />}
          />

          <div className="ml-8 space-y-2">
            <EnergyFlowBar
              label="├─ Self-Consumed (Saved $)"
              value={energy.solar_self_consumed_kwh}
              total={energy.solar_produced_kwh}
              color="bg-green-500"
              showPercentage={true}
            />

            <EnergyFlowBar
              label="└─ Exported to Grid (Revenue)"
              value={energy.grid_export_kwh}
              total={energy.solar_produced_kwh}
              color="bg-blue-500"
              showPercentage={true}
            />
          </div>

          <EnergyFlowBar
            label="Load Consumed"
            value={energy.load_consumed_kwh}
            total={energy.load_consumed_kwh}
            color="bg-purple-500"
            icon={<Zap className="w-4 h-4" />}
          />

          <div className="ml-8 space-y-2">
            <EnergyFlowBar
              label="├─ From Solar (Free)"
              value={energy.solar_self_consumed_kwh}
              total={energy.load_consumed_kwh}
              color="bg-green-500"
              showPercentage={true}
            />

            <EnergyFlowBar
              label="└─ From Grid (Paid $)"
              value={energy.grid_import_kwh}
              total={energy.load_consumed_kwh}
              color="bg-red-500"
              showPercentage={true}
            />
          </div>
        </div>
      </div>

      {/* ROI Calculator */}
      <div className="bg-gradient-to-br from-green-50 to-blue-50 rounded-lg shadow-sm border border-green-200 p-6">
        <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
          <PiggyBank className="w-5 h-5 text-green-600" />
          Return on Investment (ROI) Estimate
        </h3>

        <div className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
              <label className="text-xs text-gray-600 block mb-1">System Cost ($)</label>
              <input
                type="number"
                defaultValue={25000}
                className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
              />
            </div>

            <div>
              <label className="text-xs text-gray-600 block mb-1">Monthly Savings</label>
              <input
                type="text"
                value={`$${(costs.net_savings / costData.period.days * 30).toFixed(2)}`}
                disabled
                className="w-full px-3 py-2 border border-gray-300 rounded text-sm bg-gray-50"
              />
            </div>

            <div>
              <label className="text-xs text-gray-600 block mb-1">Payback Period</label>
              <input
                type="text"
                value={`${(25000 / (costs.net_savings / costData.period.days * 365)).toFixed(1)} years`}
                disabled
                className="w-full px-3 py-2 border border-gray-300 rounded text-sm bg-gray-50"
              />
            </div>
          </div>

          <div className="bg-white rounded-lg p-4 border border-green-200">
            <p className="text-sm text-gray-700">
              <strong>25-Year Savings Projection:</strong> ${((costs.net_savings / costData.period.days * 365 * 25)).toLocaleString(undefined, { maximumFractionDigits: 0 })}
            </p>
            <p className="text-xs text-gray-500 mt-1">
              Assumes current rates remain constant. Actual savings may increase with rising energy costs.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}

function CostCard({
  icon,
  title,
  value,
  subtitle,
  color,
  highlight = false
}: {
  icon: React.ReactNode
  title: string
  value: string
  subtitle: string
  color: string
  highlight?: boolean
}) {
  return (
    <div className={`bg-white rounded-lg shadow-sm border p-4 ${highlight ? 'border-purple-300 ring-2 ring-purple-200' : 'border-gray-200'}`}>
      <div className="flex items-start gap-3">
        {icon}
        <div className="flex-1">
          <p className="text-sm text-gray-600 mb-1">{title}</p>
          <p className={`text-2xl font-bold ${color}`}>{value}</p>
          <p className="text-xs text-gray-500 mt-1">{subtitle}</p>
        </div>
      </div>
    </div>
  )
}

function EnergyFlowBar({
  label,
  value,
  total,
  color,
  icon,
  showPercentage = false
}: {
  label: string
  value: number
  total: number
  color: string
  icon?: React.ReactNode
  showPercentage?: boolean
}) {
  const percentage = (value / total) * 100

  return (
    <div>
      <div className="flex justify-between items-center mb-1">
        <span className="text-sm text-gray-700 flex items-center gap-2">
          {icon}
          {label}
        </span>
        <span className="text-sm font-medium text-gray-900">
          {value.toFixed(1)} kWh
          {showPercentage && ` (${percentage.toFixed(1)}%)`}
        </span>
      </div>
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div
          className={`${color} h-2 rounded-full transition-all duration-500`}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  )
}
```

### Step 2.5: Create Predictive Analytics Component

**File:** `vercel/src/components/energy/PredictiveAnalytics.tsx`

```tsx
'use client'

import { TrendingUp, AlertTriangle, Lightbulb, Battery } from 'lucide-react'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine } from 'recharts'
import { format } from 'date-fns'

interface SOCPrediction {
  timestamp: string
  hour: number
  predicted_soc: number
  confidence: 'high' | 'medium' | 'low'
}

interface PredictionData {
  current_soc: number
  prediction_hours: number
  predictions: SOCPrediction[]
  model: string
  note: string
}

interface PredictiveAnalyticsProps {
  predictionData: PredictionData | null
  loading: boolean
}

export function PredictiveAnalytics({ predictionData, loading }: PredictiveAnalyticsProps) {
  if (loading) {
    return (
      <div className="text-center py-8 text-gray-500">
        Loading predictions...
      </div>
    )
  }

  if (!predictionData) {
    return (
      <div className="text-center py-8 text-gray-500">
        No prediction data available
      </div>
    )
  }

  const { current_soc, predictions } = predictionData

  // Find critical points
  const lowestSOC = Math.min(...predictions.map(p => p.predicted_soc))
  const highestSOC = Math.max(...predictions.map(p => p.predicted_soc))
  const willGoCritical = lowestSOC < 20
  const willFullyCharge = highestSOC > 95

  // Format data for chart
  const chartData = [
    {
      time: 'Now',
      soc: current_soc,
      confidence: 'current'
    },
    ...predictions.map(p => ({
      time: format(new Date(p.timestamp), 'ha'),
      soc: p.predicted_soc,
      confidence: p.confidence
    }))
  ]

  return (
    <div className="space-y-6">
      {/* Current Status */}
      <div className="bg-gradient-to-br from-blue-50 to-purple-50 rounded-lg shadow-sm border border-blue-200 p-6">
        <div className="flex items-start justify-between">
          <div>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Current Battery Status</h3>
            <p className="text-4xl font-bold text-blue-600">{current_soc.toFixed(1)}%</p>
            <p className="text-sm text-gray-600 mt-1">State of Charge</p>
          </div>
          <Battery className="w-12 h-12 text-blue-600" />
        </div>
      </div>

      {/* Prediction Chart */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">24-Hour SOC Forecast</h3>

        <ResponsiveContainer width="100%" height={300}>
          <LineChart data={chartData}>
            <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
            <XAxis
              dataKey="time"
              tick={{ fontSize: 12 }}
            />
            <YAxis
              label={{ value: 'SOC (%)', angle: -90, position: 'insideLeft' }}
              tick={{ fontSize: 12 }}
              domain={[0, 100]}
            />
            <Tooltip
              contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
              formatter={(value: number) => `${value.toFixed(1)}%`}
            />
            <Legend />

            {/* Warning zones */}
            <ReferenceLine
              y={20}
              stroke="#ef4444"
              strokeDasharray="3 3"
              label={{ value: 'Low Battery', position: 'right', fill: '#ef4444' }}
            />
            <ReferenceLine
              y={80}
              stroke="#22c55e"
              strokeDasharray="3 3"
              label={{ value: 'Well Charged', position: 'right', fill: '#22c55e' }}
            />

            <Line
              type="monotone"
              dataKey="soc"
              stroke="#3b82f6"
              strokeWidth={3}
              dot={{ fill: '#3b82f6', r: 4 }}
              name="Predicted SOC"
            />
          </LineChart>
        </ResponsiveContainer>

        <div className="mt-4 p-3 bg-gray-50 rounded-lg">
          <p className="text-xs text-gray-600">
            <strong>Model:</strong> {predictionData.model} • {predictionData.note}
          </p>
        </div>
      </div>

      {/* Insights & Recommendations */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
          <Lightbulb className="w-5 h-5 text-yellow-600" />
          Smart Recommendations
        </h3>

        <div className="space-y-3">
          {willGoCritical && (
            <RecommendationCard
              type="warning"
              title="Low Battery Alert"
              message={`Your battery is predicted to drop to ${lowestSOC.toFixed(1)}% within 24 hours. Consider reducing non-essential loads or charging from grid.`}
              icon={<AlertTriangle className="w-5 h-5" />}
            />
          )}

          {willFullyCharge && (
            <RecommendationCard
              type="success"
              title="Full Charge Expected"
              message={`Your battery will reach ${highestSOC.toFixed(1)}% charge. Excess solar energy will be available for export to grid.`}
              icon={<TrendingUp className="w-5 h-5" />}
            />
          )}

          {current_soc > 50 && lowestSOC > 30 && (
            <RecommendationCard
              type="info"
              title="Optimal Performance"
              message="Your battery levels look healthy for the next 24 hours. No action needed."
              icon={<Battery className="w-5 h-5" />}
            />
          )}

          {/* Time-based recommendations */}
          {predictions.filter(p => p.hour >= 18 && p.hour <= 22 && p.predicted_soc < 40).length > 0 && (
            <RecommendationCard
              type="warning"
              title="Evening Peak Alert"
              message="Low battery predicted during evening peak hours (6-10 PM). Consider pre-charging or shifting heavy loads to off-peak times."
              icon={<AlertTriangle className="w-5 h-5" />}
            />
          )}
        </div>
      </div>

      {/* Prediction Confidence */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">Prediction Confidence</h3>

        <div className="space-y-3">
          <ConfidenceBar
            label="High Confidence (Historical Data)"
            count={predictions.filter(p => p.confidence === 'high').length}
            total={predictions.length}
            color="bg-green-500"
          />

          <ConfidenceBar
            label="Medium Confidence (Estimated)"
            count={predictions.filter(p => p.confidence === 'medium').length}
            total={predictions.length}
            color="bg-yellow-500"
          />

          <ConfidenceBar
            label="Low Confidence (Limited Data)"
            count={predictions.filter(p => p.confidence === 'low').length}
            total={predictions.length}
            color="bg-red-500"
          />
        </div>

        <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <p className="text-xs text-blue-800">
            <strong>Note:</strong> Predictions are based on historical patterns and may vary due to weather conditions,
            usage changes, or unexpected events. Always maintain adequate battery reserves for critical loads.
          </p>
        </div>
      </div>
    </div>
  )
}

function RecommendationCard({
  type,
  title,
  message,
  icon
}: {
  type: 'success' | 'warning' | 'info'
  title: string
  message: string
  icon: React.ReactNode
}) {
  const styles = {
    success: {
      bg: 'bg-green-50',
      border: 'border-green-200',
      text: 'text-green-800',
      icon: 'text-green-600'
    },
    warning: {
      bg: 'bg-orange-50',
      border: 'border-orange-200',
      text: 'text-orange-800',
      icon: 'text-orange-600'
    },
    info: {
      bg: 'bg-blue-50',
      border: 'border-blue-200',
      text: 'text-blue-800',
      icon: 'text-blue-600'
    }
  }

  const style = styles[type]

  return (
    <div className={`${style.bg} border ${style.border} rounded-lg p-4`}>
      <div className="flex items-start gap-3">
        <div className={style.icon}>{icon}</div>
        <div className="flex-1">
          <h4 className={`text-sm font-semibold ${style.text} mb-1`}>{title}</h4>
          <p className={`text-sm ${style.text}`}>{message}</p>
        </div>
      </div>
    </div>
  )
}

function ConfidenceBar({
  label,
  count,
  total,
  color
}: {
  label: string
  count: number
  total: number
  color: string
}) {
  const percentage = (count / total) * 100

  return (
    <div>
      <div className="flex justify-between items-center mb-1">
        <span className="text-sm text-gray-700">{label}</span>
        <span className="text-sm font-medium text-gray-900">
          {count} of {total} hours ({percentage.toFixed(0)}%)
        </span>
      </div>
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div
          className={`${color} h-2 rounded-full transition-all duration-500`}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  )
}
```

### Step 2.5: Create Excess Energy Dashboard Component ⚡ CRITICAL

**File:** `vercel/src/components/energy/ExcessEnergyDashboard.tsx`

This is the **most important component** - it tracks wasted solar power and recommends actions:

```tsx
'use client'

import { AlertTriangle, Zap, TrendingUp, Lightbulb, Clock, DollarSign } from 'lucide-react'
import { AreaChart, Area, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'
import { format } from 'date-fns'

interface ExcessDataPoint {
  timestamp: string
  excess_power: number
  battery_soc: number
}

interface LoadOpportunity {
  type: 'immediate' | 'scheduled' | 'warning'
  load: string
  action: string
  power_available: number
  reason: string
  priority: 'high' | 'medium' | 'low'
  duration_estimate: string
  scheduled_time?: string
}

interface ExcessEnergyData {
  period: {
    hours: number
    start: string
    end: string
  }
  summary: {
    total_excess_kwh: number
    avg_excess_power_w: number
    peak_excess_power_w: number
    potential_value_usd: number
    data_points: number
  }
  time_series: ExcessDataPoint[]
  peak_excess_times: ExcessDataPoint[]
  hourly_patterns: Record<string, number>
  recommendations: {
    best_load_hours: Array<{
      hour: string
      avg_excess_w: number
      potential_kwh_daily: number
    }>
    suggested_actions: Array<{
      priority: string
      action: string
      details: string
      potential_revenue?: string
      potential_savings?: string
    }>
  }
}

interface LoadOpportunitiesData {
  current_status: {
    solar_power_w: number
    load_power_w: number
    battery_soc_pct: number
    excess_power_w: number
    grid_power_w: number
  }
  opportunities: LoadOpportunity[]
  summary: {
    total_opportunities: number
    immediate_actions: number
    scheduled_actions: number
    warnings: number
  }
}

interface ExcessEnergyDashboardProps {
  excessData: ExcessEnergyData | null
  loadOpportunities: LoadOpportunitiesData | null
  loading: boolean
}

export function ExcessEnergyDashboard({ excessData, loadOpportunities, loading }: ExcessEnergyDashboardProps) {
  if (loading) {
    return (
      <div className="text-center py-8 text-gray-500">
        Analyzing excess energy patterns...
      </div>
    )
  }

  if (!excessData || !loadOpportunities) {
    return (
      <div className="text-center py-8 text-gray-500">
        No excess energy data available
      </div>
    )
  }

  const { summary, time_series, hourly_patterns, recommendations } = excessData

  // Calculate waste percentage
  const wastePercentage = summary.total_excess_kwh > 0 ? 100 : 0

  return (
    <div className="space-y-6">
      {/* ⚡ CRITICAL ALERT - Wasted Energy */}
      {summary.total_excess_kwh > 1 && (
        <div className="bg-gradient-to-r from-red-50 to-orange-50 border-4 border-red-400 rounded-lg p-8 shadow-lg">
          <div className="flex items-start gap-6">
            <div className="flex-shrink-0">
              <AlertTriangle className="w-16 h-16 text-red-600 animate-pulse" />
            </div>
            <div className="flex-1">
              <h2 className="text-3xl font-bold text-red-900 mb-3">
                🚨 WASTED SOLAR ENERGY ALERT
              </h2>
              <p className="text-lg text-red-800 mb-4">
                You are <strong>LOSING {summary.total_excess_kwh.toFixed(1)} kWh</strong> of solar energy per day!
                This is power that could be generating revenue or running ranch operations instead of going to waste.
              </p>

              <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div className="bg-white rounded-lg p-4 border-2 border-red-300 shadow">
                  <div className="flex items-center gap-2 mb-2">
                    <Zap className="w-5 h-5 text-red-600" />
                    <p className="text-sm text-gray-600 font-medium">Wasted Today</p>
                  </div>
                  <p className="text-3xl font-bold text-red-600">{summary.total_excess_kwh.toFixed(1)}</p>
                  <p className="text-xs text-gray-500 mt-1">kWh lost</p>
                </div>

                <div className="bg-white rounded-lg p-4 border-2 border-orange-300 shadow">
                  <div className="flex items-center gap-2 mb-2">
                    <DollarSign className="w-5 h-5 text-green-600" />
                    <p className="text-sm text-gray-600 font-medium">Lost Value</p>
                  </div>
                  <p className="text-3xl font-bold text-green-600">${summary.potential_value_usd.toFixed(2)}</p>
                  <p className="text-xs text-gray-500 mt-1">per day</p>
                </div>

                <div className="bg-white rounded-lg p-4 border-2 border-blue-300 shadow">
                  <div className="flex items-center gap-2 mb-2">
                    <Zap className="w-5 h-5 text-blue-600" />
                    <p className="text-sm text-gray-600 font-medium">Peak Waste</p>
                  </div>
                  <p className="text-3xl font-bold text-blue-600">{summary.peak_excess_power_w.toFixed(0)}</p>
                  <p className="text-xs text-gray-500 mt-1">Watts</p>
                </div>

                <div className="bg-white rounded-lg p-4 border-2 border-purple-300 shadow">
                  <div className="flex items-center gap-2 mb-2">
                    <TrendingUp className="w-5 h-5 text-purple-600" />
                    <p className="text-sm text-gray-600 font-medium">Annual Loss</p>
                  </div>
                  <p className="text-3xl font-bold text-purple-600">${(summary.potential_value_usd * 365).toFixed(0)}</p>
                  <p className="text-xs text-gray-500 mt-1">per year</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Real-Time Load Opportunities */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-xl font-semibold mb-4 flex items-center gap-2">
          <Lightbulb className="w-6 h-6 text-yellow-600" />
          Load Opportunities Right Now
        </h3>

        {loadOpportunities.opportunities.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            No immediate opportunities. System is optimally balanced.
          </div>
        ) : (
          <div className="space-y-4">
            {loadOpportunities.opportunities.map((opp, idx) => (
              <LoadOpportunityCard key={idx} opportunity={opp} />
            ))}
          </div>
        )}
      </div>

      {/* Excess Energy Chart */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-xl font-semibold mb-4">Excess Energy Over Time</h3>

        <ResponsiveContainer width="100%" height={300}>
          <AreaChart data={time_series.map(d => ({
            time: format(new Date(d.timestamp), 'HH:mm'),
            excess: d.excess_power,
            soc: d.battery_soc
          }))}>
            <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
            <XAxis
              dataKey="time"
              tick={{ fontSize: 12 }}
              interval="preserveStartEnd"
            />
            <YAxis
              yAxisId="left"
              label={{ value: 'Excess Power (W)', angle: -90, position: 'insideLeft' }}
              tick={{ fontSize: 12 }}
            />
            <YAxis
              yAxisId="right"
              orientation="right"
              label={{ value: 'Battery SOC (%)', angle: 90, position: 'insideRight' }}
              tick={{ fontSize: 12 }}
            />
            <Tooltip
              contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
            />
            <Legend />
            <Area
              yAxisId="left"
              type="monotone"
              dataKey="excess"
              stroke="#ef4444"
              fill="#fecaca"
              name="Wasted Power (W)"
            />
            <Area
              yAxisId="right"
              type="monotone"
              dataKey="soc"
              stroke="#3b82f6"
              fill="#dbeafe"
              fillOpacity={0.3}
              name="Battery SOC (%)"
            />
          </AreaChart>
        </ResponsiveContainer>

        <div className="mt-4 p-4 bg-orange-50 border border-orange-200 rounded">
          <p className="text-sm text-orange-800">
            <strong>Red areas</strong> show wasted solar power - energy that could be powering miners, pumps, or other loads.
            Notice how excess occurs when battery is full (high SOC) but solar production continues.
          </p>
        </div>
      </div>

      {/* Best Hours to Run Loads */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-xl font-semibold mb-4">Best Hours for Heavy Loads</h3>

        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={Object.entries(hourly_patterns).map(([hour, avg]) => ({
            hour: `${hour}:00`,
            excess: avg
          }))}>
            <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
            <XAxis
              dataKey="hour"
              tick={{ fontSize: 12 }}
            />
            <YAxis
              label={{ value: 'Avg Excess Power (W)', angle: -90, position: 'insideLeft' }}
              tick={{ fontSize: 12 }}
            />
            <Tooltip
              contentStyle={{ backgroundColor: '#fff', border: '1px solid #e5e7eb' }}
              formatter={(value: number) => `${value.toFixed(0)}W`}
            />
            <Bar
              dataKey="excess"
              fill="#f59e0b"
              radius={[8, 8, 0, 0]}
            />
          </BarChart>
        </ResponsiveContainer>

        <div className="mt-4">
          <h4 className="font-semibold text-gray-900 mb-3">Recommended Schedule:</h4>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
            {recommendations.best_load_hours.slice(0, 6).map((hour, idx) => (
              <div key={idx} className="bg-gradient-to-r from-yellow-50 to-orange-50 border border-yellow-300 rounded p-3">
                <div className="flex items-center gap-2 mb-1">
                  <Clock className="w-4 h-4 text-yellow-600" />
                  <p className="font-bold text-gray-900">{hour.hour}</p>
                </div>
                <p className="text-sm text-gray-700">{hour.avg_excess_w}W available</p>
                <p className="text-xs text-gray-600 mt-1">{hour.potential_kwh_daily} kWh/day potential</p>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Action Recommendations */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-xl font-semibold mb-4 flex items-center gap-2">
          <Lightbulb className="w-6 h-6 text-yellow-600" />
          Recommended Actions
        </h3>

        <div className="space-y-4">
          {recommendations.suggested_actions.map((action, idx) => (
            <ActionCard key={idx} action={action} />
          ))}
        </div>
      </div>
    </div>
  )
}

function LoadOpportunityCard({ opportunity }: { opportunity: LoadOpportunity }) {
  const bgColors = {
    immediate: 'bg-green-50 border-green-300',
    scheduled: 'bg-blue-50 border-blue-300',
    warning: 'bg-red-50 border-red-300'
  }

  const iconColors = {
    immediate: 'text-green-600',
    scheduled: 'text-blue-600',
    warning: 'text-red-600'
  }

  const priorityColors = {
    high: 'bg-red-100 text-red-800',
    medium: 'bg-yellow-100 text-yellow-800',
    low: 'bg-gray-100 text-gray-800'
  }

  return (
    <div className={`${bgColors[opportunity.type]} border-2 rounded-lg p-4`}>
      <div className="flex items-start justify-between mb-2">
        <div className="flex items-center gap-2">
          <Zap className={`w-5 h-5 ${iconColors[opportunity.type]}`} />
          <h4 className="font-bold text-gray-900">{opportunity.load}</h4>
        </div>
        <span className={`text-xs px-2 py-1 rounded-full font-medium ${priorityColors[opportunity.priority]}`}>
          {opportunity.priority.toUpperCase()}
        </span>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-3">
        <div>
          <p className="text-xs text-gray-600">Action</p>
          <p className="font-semibold text-gray-900">{opportunity.action}</p>
        </div>
        <div>
          <p className="text-xs text-gray-600">Power Available</p>
          <p className="font-semibold text-gray-900">{opportunity.power_available}W</p>
        </div>
        <div>
          <p className="text-xs text-gray-600">Duration</p>
          <p className="font-semibold text-gray-900">{opportunity.duration_estimate}</p>
        </div>
      </div>

      <p className="text-sm text-gray-700 mb-2">{opportunity.reason}</p>

      {opportunity.scheduled_time && (
        <div className="flex items-center gap-2 text-sm text-blue-700 mt-2">
          <Clock className="w-4 h-4" />
          <span>Scheduled for: {opportunity.scheduled_time}</span>
        </div>
      )}
    </div>
  )
}

function ActionCard({ action }: { action: any }) {
  const priorityColors = {
    high: 'border-red-400 bg-red-50',
    medium: 'border-yellow-400 bg-yellow-50',
    low: 'border-gray-400 bg-gray-50'
  }

  return (
    <div className={`border-2 rounded-lg p-4 ${priorityColors[action.priority]}`}>
      <div className="flex items-start justify-between mb-2">
        <h4 className="font-bold text-gray-900 text-lg">{action.action}</h4>
        <span className="text-xs px-2 py-1 rounded-full bg-white font-medium">
          {action.priority.toUpperCase()} PRIORITY
        </span>
      </div>

      <p className="text-gray-700 mb-3">{action.details}</p>

      {action.potential_revenue && (
        <div className="flex items-center gap-2 text-green-700 font-medium">
          <DollarSign className="w-4 h-4" />
          <span>Potential Revenue: {action.potential_revenue}</span>
        </div>
      )}

      {action.potential_savings && (
        <div className="flex items-center gap-2 text-blue-700 font-medium">
          <TrendingUp className="w-4 h-4" />
          <span>Potential Savings: {action.potential_savings}</span>
        </div>
      )}
    </div>
  )
}
```

### Step 2.6: Integrate Everything into Main Energy Page

**File:** `vercel/src/app/energy/page.tsx`

Add tab navigation to the existing energy page:

```tsx
// Add imports at top
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { PowerFlowChart, SOCComparisonChart, BatteryVoltageChart, BatteryCurrentChart, TemperatureChart } from '@/components/energy/HistoricalCharts'
import { EnergyStatistics } from '@/components/energy/EnergyStatistics'
import { CostTracking } from '@/components/energy/CostTracking'
import { PredictiveAnalytics } from '@/components/energy/PredictiveAnalytics'
import { ExcessEnergyDashboard } from '@/components/energy/ExcessEnergyDashboard'  // ⚡ CRITICAL

// Add state for new data
const [historicalData, setHistoricalData] = useState([])
const [dailyStats, setDailyStats] = useState([])
const [costData, setCostData] = useState(null)
const [predictionData, setPredictionData] = useState(null)
const [excessData, setExcessData] = useState(null)             // ⚡ CRITICAL
const [loadOpportunities, setLoadOpportunities] = useState(null)  // ⚡ CRITICAL
const [timeRange, setTimeRange] = useState(24)

// Add fetch calls in useEffect
useEffect(() => {
  const fetchAllData = async () => {
    try {
      const API_URL = process.env.NEXT_PUBLIC_API_URL || 'https://api.wildfireranch.us'

      // ... existing fetches ...

      // Fetch historical data
      const historyRes = await fetch(`${API_URL}/energy/history?hours=${timeRange}&limit=1000`)
      if (historyRes.ok) {
        const response = await historyRes.json()
        setHistoricalData(response.data)
      }

      // Fetch daily stats
      const statsRes = await fetch(`${API_URL}/energy/analytics/daily?days=30`)
      if (statsRes.ok) {
        const response = await statsRes.json()
        setDailyStats(response.data)
      }

      // Fetch cost data
      const today = new Date()
      const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000)
      const costRes = await fetch(
        `${API_URL}/energy/analytics/cost?start_date=${thirtyDaysAgo.toISOString().split('T')[0]}&end_date=${today.toISOString().split('T')[0]}`
      )
      if (costRes.ok) {
        const response = await costRes.json()
        setCostData(response)
      }

      // Fetch predictions
      const predRes = await fetch(`${API_URL}/energy/predictions/soc?hours=24`)
      if (predRes.ok) {
        const response = await predRes.json()
        setPredictionData(response)
      }

      // ⚡ CRITICAL: Fetch excess energy data
      const excessRes = await fetch(`${API_URL}/energy/analytics/excess?hours=${timeRange}`)
      if (excessRes.ok) {
        const response = await excessRes.json()
        setExcessData(response)
      }

      // ⚡ CRITICAL: Fetch load opportunities
      const oppRes = await fetch(`${API_URL}/energy/analytics/load-opportunities`)
      if (oppRes.ok) {
        const response = await oppRes.json()
        setLoadOpportunities(response)
      }

      setLastUpdate(new Date())
    } catch (error) {
      console.error('Failed to fetch energy data:', error)
    } finally {
      setLoading(false)
    }
  }

  fetchAllData()
  const interval = setInterval(fetchAllData, 60000) // Refresh every minute
  return () => clearInterval(interval)
}, [timeRange])

// Add tabs UI after existing dashboard content
<Tabs defaultValue="excess" className="mt-8">
  <TabsList className="grid w-full grid-cols-6">
    <TabsTrigger value="excess" className="text-orange-600 font-bold">⚡ Excess Energy</TabsTrigger>
    <TabsTrigger value="realtime">Real-Time</TabsTrigger>
    <TabsTrigger value="trends">Historical Trends</TabsTrigger>
    <TabsTrigger value="stats">Statistics</TabsTrigger>
    <TabsTrigger value="costs">Cost Tracking</TabsTrigger>
    <TabsTrigger value="predictions">Predictions</TabsTrigger>
  </TabsList>

  <TabsContent value="excess">
    <ExcessEnergyDashboard
      excessData={excessData}
      loadOpportunities={loadOpportunities}
      loading={loading}
    />
  </TabsContent>

  <TabsContent value="realtime">
    {/* Existing real-time dashboard content */}
  </TabsContent>

  <TabsContent value="trends" className="space-y-6">
    <div className="flex justify-between items-center">
      <h2 className="text-2xl font-bold">Historical Trends</h2>
      <select
        value={timeRange}
        onChange={(e) => setTimeRange(parseInt(e.target.value))}
        className="px-4 py-2 border border-gray-300 rounded-lg"
      >
        <option value={6}>Last 6 hours</option>
        <option value={12}>Last 12 hours</option>
        <option value={24}>Last 24 hours</option>
        <option value={48}>Last 48 hours</option>
        <option value={72}>Last 72 hours</option>
        <option value={168}>Last 7 days</option>
      </select>
    </div>

    <div className="grid grid-cols-1 gap-6">
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">Power Flow Over Time</h3>
        <PowerFlowChart data={historicalData} />
      </div>

      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">Battery SOC: Victron vs SolArk</h3>
        <SOCComparisonChart data={historicalData} />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h3 className="text-lg font-semibold mb-4">Battery Voltage</h3>
          <BatteryVoltageChart data={historicalData} />
        </div>

        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h3 className="text-lg font-semibold mb-4">Battery Current</h3>
          <BatteryCurrentChart data={historicalData} />
        </div>
      </div>

      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 className="text-lg font-semibold mb-4">Battery Temperature</h3>
        <TemperatureChart data={historicalData} />
      </div>
    </div>
  </TabsContent>

  <TabsContent value="stats">
    <EnergyStatistics dailyStats={dailyStats} period="month" />
  </TabsContent>

  <TabsContent value="costs">
    <CostTracking costData={costData} loading={loading} />
  </TabsContent>

  <TabsContent value="predictions">
    <PredictiveAnalytics predictionData={predictionData} loading={loading} />
  </TabsContent>
</Tabs>
```

---

## PHASE 3: Testing & Optimization (2-3 hours)

### Step 3.1: Backend Testing

Test all new endpoints:

```bash
# Test energy history
curl "https://api.wildfireranch.us/energy/history?hours=24&limit=100"

# Test daily analytics
curl "https://api.wildfireranch.us/energy/analytics/daily?days=30"

# Test cost tracking
curl "https://api.wildfireranch.us/energy/analytics/cost?start_date=2025-01-01&end_date=2025-01-31"

# Test predictions
curl "https://api.wildfireranch.us/energy/predictions/soc?hours=24"
```

### Step 3.2: Frontend Testing

1. **Load Dashboard**
   ```bash
   cd /workspaces/CommandCenter/vercel
   npm run dev
   # Navigate to http://localhost:3000/energy
   ```

2. **Verify Each Tab**
   - ✅ Real-Time tab shows live data
   - ✅ Historical Trends tab renders all charts
   - ✅ Statistics tab shows daily breakdowns
   - ✅ Cost Tracking tab calculates correctly
   - ✅ Predictions tab displays forecasts

3. **Test Time Range Selector**
   - ✅ 6h, 12h, 24h, 48h, 72h, 7d ranges work
   - ✅ Charts update without flickering
   - ✅ Data loads within 2 seconds

4. **Test Responsive Design**
   - ✅ Desktop: Full width charts
   - ✅ Tablet: 2-column layouts
   - ✅ Mobile: Stacked cards

### Step 3.3: Performance Optimization

1. **Add Data Caching**
   - Cache historical data for 5 minutes
   - Cache daily stats for 1 hour
   - Cache predictions for 30 minutes

2. **Optimize Database Queries**
   - Add indexes on `created_at` and `timestamp` columns
   - Use query limits to prevent excessive data transfer
   - Consider PostgreSQL materialized views for daily stats

3. **Frontend Optimization**
   - Lazy load chart components
   - Debounce time range selector
   - Use React.memo for expensive components

---

## 📊 Expected Results

After completion, users will have:

1. **Comprehensive Historical View**
   - Power flow trends over time
   - Battery voltage, current, temperature charts
   - SOC comparison between Victron and SolArk

2. **Actionable Statistics**
   - Daily/weekly/monthly energy production
   - Solar self-consumption percentage
   - Grid independence metrics
   - Peak power times

3. **Financial Insights**
   - Grid import/export costs
   - Solar savings calculations
   - ROI projections
   - 25-year savings forecast

4. **Predictive Intelligence**
   - 24-hour battery SOC forecast
   - Low battery alerts
   - Peak usage recommendations
   - Optimal charging times

---

## ✅ Definition of Done

**This feature is complete when:**

- ✅ All 4 backend endpoints implemented and tested
- ✅ All 5 frontend components render correctly
- ✅ Tab navigation works smoothly
- ✅ Charts display data accurately
- ✅ Time range selector functions properly
- ✅ Cost calculations are accurate
- ✅ Predictions display with confidence levels
- ✅ Mobile responsive on all screen sizes
- ✅ Page loads in < 3 seconds
- ✅ No console errors or warnings
- ✅ Data auto-refreshes every minute
- ✅ Export functionality works (bonus)

---

## 🚀 Deployment Checklist

1. **Backend**
   - [ ] Database migrations applied
   - [ ] Indexes created on timestamp columns
   - [ ] API endpoints documented in Swagger/OpenAPI
   - [ ] Environment variables configured
   - [ ] Deployed to Railway

2. **Frontend**
   - [ ] Dependencies installed (`recharts`, `date-fns`)
   - [ ] Components built without errors
   - [ ] Environment variables set (API_URL)
   - [ ] Production build successful
   - [ ] Deployed to Vercel

3. **Testing**
   - [ ] Manual testing completed
   - [ ] All tabs functional
   - [ ] Charts render correctly
   - [ ] Cost calculations verified
   - [ ] Mobile responsive confirmed

---

## 📚 Related Files

### Backend Files to Modify/Create:
- `railway/src/api/main.py` - Add 4 new endpoints
- `railway/src/utils/db.py` - Add helper queries (optional)
- `railway/src/utils/analytics.py` - Create analytics utilities (optional)

### Frontend Files to Create:
- `vercel/src/components/energy/HistoricalCharts.tsx`
- `vercel/src/components/energy/EnergyStatistics.tsx`
- `vercel/src/components/energy/CostTracking.tsx`
- `vercel/src/components/energy/PredictiveAnalytics.tsx`

### Frontend Files to Modify:
- `vercel/src/app/energy/page.tsx` - Add tab navigation and integrate components

---

## 💡 Future Enhancements (V1.8+)

- **PDF Report Generation**: Export monthly/yearly reports
- **Email Alerts**: Notify on critical battery levels or high costs
- **Weather Integration**: Correlate solar production with weather data
- **Machine Learning**: Advanced predictions using TensorFlow.js
- **Comparison Tools**: Compare performance month-over-month
- **Budget Tracking**: Set energy budgets and track progress
- **Peak Demand Analysis**: Identify and optimize high-usage periods

---

**Ready to implement V1.7!** 🚀

Copy this prompt and begin with Phase 1 (Backend API Endpoints). Work through each phase sequentially for best results.

---

**Estimated Timeline:**
- Phase 1 (Backend): 4-5 hours
- Phase 2 (Frontend): 4-6 hours
- Phase 3 (Testing): 2-3 hours
- **Total: 10-14 hours** (can be split across multiple sessions)
